---
title: 生成应用脚手架学习
date: 2021-04-27 16:26:55
tags: 框架
toc: true
excerpt: 开发node cli脚手架
cover: /img/apass.jpg
categories: 
  - 前端
  - 框架
---
# 一、基础学习 开发node cli脚手架流程

## 1、 初始化 npm init -y 创建package.json

修改package.json加入常用依赖包

自动初始化一个项目的流程主要是以下三点：

* 读取用户配置
* 读取模板文件
* 根据配置，编译模板文件，输出最终文件

所需常用依赖：

### （1）配置信息工具

#### commander

一个帮助快速开发Nodejs命令行工具的package

* **version**

定义版本号

```javascript
var program = require('commander');
 
program
    .version('0.0.1')
    .parse(process.argv);
    //添加参数解析
#执行结果：
node index.js -V
 
0.0.1
#如果希望程序响应-v选项而不是-V选项，
#只需使用与option方法相同的语法将自定义标志传递给version方法
program
  .version('0.0.1', '-v, --version')
```
* **option**
    * 使用**.option()**方法定义**commander**的选项**options**
    * 示例：.option('-n, --name <items1> [items2]', 'name description', 'default value')
    * 参数解析：
        1. 自定义标志<必须>：分为长短标识，中间用逗号、竖线或者空格分割；标志后面可跟必须参数或可选参数，前者用`<>`包含，后者用`[]`包含
        2. 选项描述<省略不报错>：在使用 --help 命令时显示标志描述
        3. 默认值<可省略>
        4. 短标志可以作为单独的参数传递。像 -abc 等于 -a -b -c。多词组成的选项，像“--template-engine”会变成 program.templateEngine 等。
* **command**
    * 作用：添加命令名称
    * 示例：`.command('add <num>[otherDirs...]', 'install description', opts)`
    * 参数解析：
        1. 命令名称<必须>：命令后面可跟用 <> 或 [] 包含的参数；命令的最后一个参数可以是可变的，像实例中那样在数组后面加入 ... 标志；在命令后面传入的参数会被传入到 action 的回调函数以及 program.args 数组中
        2. 命令描述<可省略>：如果存在，且没有显示调用action(fn)，就会启动子命令程序，否则会报错
        3. 配置选项<可省略>：可配置noHelp、isDefault等
* **alias description usage**

定义命令的别名 描述和用法

```javascript
.alias('r')
.usage('[options] <file ...>')
.description('run setup commands for all envs')
#output
gp-cli rm --help
Usage: rm|r [options] <file ...>
run setup commands for all envs
Options:
  -r, --recursive     Remove recursively
  -d --drink [drink]  Drink
  -h, --help          output usage information
```
#### inquirer

inquirer为NodeJs做一个可嵌入式的美观的命令行界面

Inquirer.js仅仅给用户提供了一个漂亮的界面和提出问题流的方式。

它是非常容易去处理以下几种事情的：

* 提供错误回调
* 询问操作者问题
* 获取并解析用户输入
* 检测用户回答是否合法
* 管理多层级的提示

inquirer为每个问题提供很多参数：

```json
{ 
  type: String, // 表示提问的类型，下文会单独解释 
  name: String, // 在最后获取到的answers回答对象中，作为当前这个问题的键
  message: String|Function, // 打印出来的问题标题，如果为函数的话 
  default: String|Number|Array|Function, // 用户不输入回答时，问题的默认值。或者使用函数来return一个默认值。假如为函数时，函数第一个参数为当前问题的输入答案。 
  choices: Array|Function, // 给出一个选择的列表，假如是一个函数的话，第一个参数为当前问题的输入答案。为数组时，数组的每个元素可以为基本类型中的值。 
  validate: Function, // 接受用户输入，并且当值合法时，函数返回true。当函数返回false时，一个默认的错误信息会被提供给用户。 
  filter: Function, // 接受用户输入并且将值转化后返回填充入最后的answers对象内。 
  when: Function|Boolean, // 接受当前用户输入的answers对象，并且通过返回true或者false来决定是否当前的问题应该去问。也可以是简单类型的值。 
  pageSize: Number, // 改变渲染list,rawlist,expand或者checkbox时的行数的长度。
}
```
* 语法结构
```plain
const inquirer = require('inquirer');
const promptList = [
    // 具体交互内容
];
inquirer.prompt(promptList).then(answers => {
    console.log(answers); // 返回的结果
})
```
* input
```javascript
const promptList = [{
    type: 'input',
    message: '设置一个用户名:',
    name: 'name',
    default: "test_user" // 默认值
},{
    type: 'input',
    message: '请输入手机号:',
    name: 'phone',
    validate: function(val) {
        if(val.match(/\d{11}/g)) { // 校验位数
            return val;
        }
        return "请输入11位数字";
    }
}];
```
效果：
![图片](https://uploader.shimo.im/f/xYZpK8Tm0EPCD1a4.png!thumbnail?fileGuid=rdPR3Dhhv6j6VY9C)

* comfirm
```javascript
const promptList = [{
    type: "confirm",
    message: "是否使用监听？",
    name: "watch",
    prefix: "前缀"
},{
    type: "confirm",
    message: "是否进行文件过滤？",
    name: "filter",
    suffix: "后缀",
    when: function(answers) { // 当watch为true的时候才会提问当前问题
        return answers.watch
    }
}];
```
效果：
![图片](https://uploader.shimo.im/f/twOVrHA0QFENBJjU.png!thumbnail?fileGuid=rdPR3Dhhv6j6VY9C)

* list
```javascript
const promptList = [{
    type: 'list',
    message: '请选择一种水果:',
    name: 'fruit',
    choices: [
        "Apple",
        "Pear",
        "Banana"
    ],
    filter: function (val) { // 使用filter将回答变为小写
        return val.toLowerCase();
    }
}];
```
效果：
![图片](https://uploader.shimo.im/f/6ByuWJWCA83Wg1bj.png!thumbnail?fileGuid=rdPR3Dhhv6j6VY9C)

* expand
```javascript
const promptList = [{
    type: "expand",
    message: "请选择一种水果：",
    name: "fruit",
    choices: [
        {
            key: "a",
            name: "Apple",
            value: "apple"
        },
        {
            key: "O",
            name: "Orange",
            value: "orange"
        },
        {
            key: "p",
            name: "Pear",
            value: "pear"
        }
    ]
}];
```
效果：
![图片](https://uploader.shimo.im/f/MVGtNTGQyw3Sd8jy.png!thumbnail?fileGuid=rdPR3Dhhv6j6VY9C)

* password
```javascript
const promptList = [{
    type: "password", // 密码为密文输入
    message: "请输入密码：",
    name: "pwd"
}];
```
效果：
![图片](https://uploader.shimo.im/f/CBdZcRJ6iXwKKaUA.png!thumbnail?fileGuid=rdPR3Dhhv6j6VY9C)

* editor
```javascript
const promptList = [{
    type: "editor",
    message: "请输入备注：",
    name: "editor"
}];
```
效果：
![图片](https://uploader.shimo.im/f/XkG2bYBKIs29wI4O.png!thumbnail?fileGuid=rdPR3Dhhv6j6VY9C)

### （2）模板信息工具

#### **mem-fs & mem-fs-editor**

**mem-fs & mem-fs-editor**提供了一系列API，方便操作模板文件。mem-fs是对文件进行读取，存入内存中

* 读写文件

**read(filepath, [options])**：将文件内容作为string返回。options.raw = true可以返回文件原始内容buffer。文件不存在会报错，如果你不想用try-catch，可以设置options.defaults返回默认值，这样就不会报错了。

**readJSON(filepath, [defaults])**：读JSON

**write(filepath, contents)**：写文件

**writeJSON(filepath, contents[, replacer [, space]])**：写JSON

```javascript
const path = require('path');
const memFs = require("mem-fs");
const editor = require("mem-fs-editor");
const store = memFs.create();
const fs = editor.create(store);
const srcFile = path.resolve(__dirname, '../tmp/data2.txt');
const srcJson = path.resolve(__dirname, '../../package.json');
const destTpl = path.resolve(__dirname, '../tmp/dataMemFs.tpl');
const destJson = path.resolve(__dirname, '../tmp/dataMemFs.json');
fs.read(srcFile);                                   // hello world!
fs.read(srcFile, { raw: true });                    // <Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64 21>
fs.read('somefile.txt', { defaults: '文件不存在' });  // 文件不存在
fs.readJSON(srcJson);   // json对象
fs.write(destTpl, "<%= value %%gt;");
fs.writeJSON(destJson, JSON.parse(JSON.stringify({ name: "tool-demo" })));
```
* 改删文件

**append(filepath, contents, [options])**：文件末添加新内容，options.trimEnd默认为true，options.separator新旧内容间的分隔符，默认EOL

**extendJSON(filepath, contents[, replacer [, space]])**：JSON文件末添加新内容

**delete(filepath, [options])**：删文件或文件夹

```javascript
fs.append(destTpl, "<%= value2 %>", { separator: '\r\n----\r\n' });
fs.extendJSON(destJson, JSON.parse(JSON.stringify({ description: "some tool demo" })));
fs.delete(destJson);
```
* 拷贝、移动文件

**copy(from, to, [options], context[, templateOptions ])**：拷贝文件

**copyTpl(from, to, context[, templateOptions [, copyOptions]])**：拷贝模板

**move(from, to, [options])**：移动文件

```javascript
fs.copy(destTpl, path.join(__dirname, '../tmp/mem-fs/dataMemFs.tpl'));
fs.copyTpl(destTpl, path.join(__dirname, '../tmp/mem-fs/dataMemFs.txt'), {
    value: 1,
    value2: 2
});
fs.move(path.join(__dirname, '../tmp/mem-fs/dataMemFs.tpl'), destTpl);
```
* 其他

**exists(filepath)**：文件是否存在

**commit([filters,] callback)**：将内存中的文件操作全部提交到磁盘上

```javascript
fs.exists(destTpl);    // true
fs.commit(() => {});             // 同步
fs.commit(() => { resolve(); }); // 异步
```
### **（3）**提示信息工具

#### chalk

**chalk**包的作用是修改控制台中字符串的样式，包括：

1. 字体样式(加粗、隐藏等)
2. 字体颜色
3. 背景颜色

**chalk**支持两种方式使用：常规的调用方式和模板中使用的方式。

* 常规使用
* 模板使用
### （4）文件操作

#### fs-extra

#### download-git-repo

## 2、新建src文件夹，表示脚手架的源文件，创建入口main.js

## 3、 新建bin文件夹/www文件，表示使用那个核心文件

## 4、 映射命令行工具，配置指令能被node识别

## 5、 打印帮助

## 6、 配置几个常用的指令

## 7、 逻辑编写



### 











### 





# 二、best-cli解析

